#pragma rtGlobals=3		// Use modern global access method and strict wave access.
#include "CSP_FigureFormatting"	// place this ipf in the User Procedures Folder 
#include "Peak Areas"			// copy this ipf in the User Procedures Folder copy that from IgorPro folders: Technical Notes, Igor Tech Notes:TN020-B Peak Areas)
#include <Waves Average>		// already in wavemetrics analysis folder, should be called easily

//***==========================================================================***//
// This analysis code simulates the dendritic processing of random spine stimulations
// necessary inputs in root: (not generated by this code)
//				1. a kernel wave derived from the experimental data from the Event Triggered Averages
//						(This is called "ETAfilter")
//				2. A series of timepoints that are the stimulation times (called by "StS" ending)
//				Note these are assumed to be 10 s long trials, with times in ms, sampled at 20 KHz
// 				3. A series of spine numbers corresponding to each stimulation spine  (called by "SpS" ending)
//					(not necessary except for graphing, counting inputs)
//				4. The mean input rate for that generated the random stim times  (called by "Freq" ending)
//			                Inputs are often named m(mean)p(#plus or minus)c(carrier freq.)
//			To generate Figures 7 and 8			
//				the following inputs were utilized:
//					mean 12 Hz plus/minus 2 Hz on a carrier of 1 Hz
//					mean 12 Hz plus/minus 2 Hz on a carrier of 3 Hz
//					mean 12 Hz plus/minus 0 Hz on a carrier of 7 Hz
//					mean 12 Hz plus/minus 1 Hz on a carrier of 7 Hz
//					mean 12 Hz plus/minus 2 Hz on a carrier of 7 Hz
//					mean 12 Hz plus/minus 4 Hz on a carrier of 7 Hz
//					mean 12 Hz plus/minus 2 Hz on a carrier of 10 Hz
//					mean 12 Hz plus/minus 2 Hz on a carrier of 30 Hz
//					mean 12 Hz plus/minus 2 Hz on a carrier of 100 Hz
// 				Note that inputs were generated in Matlab with an inhomogenous poisson process code.
// 		*******Also, this analysis utilizes 2 Igor Analysis Packages that need to be loaded & compiled prior to use:
//					a)	Average Waves in Graph (in Menu: Analysis: Packages: AverageWaves) 
//					b)	Peak Areas.ipf (in Application folders: Technical Notes, Igor Tech Notes)
//							PeakArea code is aka TN020B
//		
// 					this analysis code was written by Nikolai Dembrow latest version 08/05/2021
//							to make figures formatted as in paper, use CSP_FigureFormatting.ipf
// 				Once you've loaded all the StS and SpS files, the ETAfilter, and the .ipf files you can begin by
//				typing StartHere() in command bar
//***==========================================================================***//				



//------------------------------------------------------------------------------------------------------------------------------------------------//
function StartHere()			// the function that runs the whole analysis, lots of prereqs see above.

make /o /n = 4 half_ratewave 		// set the half rate(s) of the sigmoid(s) you are testing
half_ratewave = {560, 760, 960, 1160}
make /o /t /n = 4 half_rateTwave 		// set the half rate(s) of the sigmoid(s) you are testing
half_rateTwave = {"0560", "0760", "0960", "1160"}
wave ETAfilter						// wave of the filter to make impulses into a continous function
variable thismanyhalfrates = numpnts(half_ratewave)
make /o /t /n = 10 inputnames		// input conditions to analyze as strings
make /o /n = (10, 2) inputprops		// carrier frequencies as numbers
inputnames = {"p2c001", "p2c003", "p0c007", "p1c007", "p2c007", "p4c007","p2c010", "p2c030", "p2c050", "p2c100"}
inputprops [][0]= {1, 3, 7, 7, 7, 7, 10, 30, 50, 100}
inputprops [][1]= {2, 2, 0, 1, 2, 4, 2, 2, 2, 2}

variable thismanyconditions = numpnts(inputnames)
make /o /n = (thismanyconditions) ET_hist_range = 0		// output waves for phase histograms
make /o /n = (thismanyconditions) IT_hist_range = 0
make /o /n = (thismanyconditions) lin_hist_range = 0
	
make /o /n = 4 plusminusvalues		// the different plus/minus values to cycle through for Figure 8F
plusminusvalues = {0, 1, 2, 4}


variable ETslope = 25
variable ITslope = 250

make /o /n = 6 DendriteParams		// What inputs to the Simple model of the dendrite, see details below
DendriteParams = {60, 0.002, 0, 12, ETslope, half_ratewave [0]}	// Number of Spines, linear compoinent (per Hz), baseline, maxvoltage, slope, half-rate
variable EThalf_rate, IThalf_rate
variable range

make /o /n = (thismanyconditions, 3, thismanyhalfrates) range_array	// output of all the ranges from all the conditions
//			10 rows (diff. input conditions), 3 columns (ET-IT-lin), and 4 half rate (560;760;960;1160)		

string rate_curvename
string peaksname
string FreqInWavename
string thispointwave, thistimewave
string AveRateName, suffix
variable thecarrier
variable thelength = 10000/0.05

variable r, i, h, w
string carrier_prefix
string pointname, timesname, filtername
string pointwaves2anal, timewaves2anal
variable numwaves 


string ETname  // name of the wave of the "voltage" output for steep or "ET" dendrite simulation
string ITname  // name of the wave of the "voltage" output for shallow or "IT" dendrite simulation
string linname // name of the wave of the "voltage" output of linear dendrite

for (r = 0; r< numpnts(inputnames); r+=1) // for loop changing carrier frequency as tracked by "r" from "carriername"  text wave

	carrier_prefix = inputnames [r]
	thecarrier = inputprops[r][0]
	pointname = carrier_prefix+"_*SpS"
	timesname = carrier_prefix+"_*StS"
	FreqInWavename = carrier_prefix+"_Freq"
	pointwaves2anal = sortlist(wavelist (pointname, ";",""))
 	timewaves2anal = sortlist(wavelist (timesname, ";",""))
 	numwaves = itemsinlist (timewaves2anal,";")
	print "analyzing: ", carrier_prefix
	print timewaves2anal
	
	
	
		for (i = 0;i<numwaves;i+=1)   // for loop going through all the waves as tracked by "i" for this carrier frequency
			thispointwave = stringfromlist (i, pointwaves2anal)
			if (waveexists($thispointwave)!=1)
				Abort "Wave \""+ thispointwave +"\" doesn't exist!"
			endif
			duplicate /o $thispointwave, TheStimPoints
			wavestats /q TheStimPoints
			DendriteParams[0] = V_max		// how many spines is calculated by the maximimum number possible on spine identity wave
			
			thistimewave = stringfromlist (i, timewaves2anal)
			print "processing...", thistimewave 
			if (waveexists($thistimewave)!=1)
				Abort "Wave \""+ thistimewave +"\" doesn't exist!"
			endif
			duplicate /o $thistimewave, InputRateWave
			AveRateName = thistimewave[0, (strsearch(thistimewave, "_StS",0))]+"etaFRate"
			print AveRateName, " = rate wave"
			if (waveexists($FreqInWavename)!=1)
				Abort "Wave \""+ FreqInWavename +"\" doesn't exist!"
			endif
			duplicate /o $FreqInWavename, tempFreqwave
			thelength = numpnts(tempFreqwave)
			// Make a continous rate function for each Stimulus Input Wave by convoluting the ETA filter with the impulse times:
			calcAveRatefromETAfilter($thistimewave, thelength, ETAfilter)
		

			wave sfrate, fscalewave
			if (waveexists(sfrate)!=1)
				Abort "Wave \""+ nameofwave(sfrate) +"\" doesn't exist!"
			endif
//			duplicate /r = (0, 9999.95) /o sfrate, $AveRateName
			duplicate /o sfrate, $AveRateName
			filtername = "Fltr4_"+AveRateName
			if (waveexists(fscalewave)!=1)
				Abort "Wave \""+ nameofwave(fscalewave) +"\" doesn't exist!"
			endif
			duplicate /o fscalewave, $filtername		
			
			//Extract peaks in rate ("W_MaxKnots") from Rate Wave [i]"
						FindMyRatePeaks($AveRateName)
						wave W_MaxKnots
					 	peaksname = thistimewave[0, (strsearch(thistimewave, "_StS",0))]+"etaRpks"
						if (waveexists(W_MaxKnots)!=1)
							Abort "Wave \""+ nameofwave(W_MaxKnots) +"\" doesn't exist!"
						endif
						duplicate /o W_MaxKnots, $peaksname				
	
			for (h = 0; h< numpnts(half_ratewave); h+=1) // loop to go through different half frequencies
				// Make the dendritic voltage response:
				// set half-rate of sigmoid
				EThalf_rate = half_ratewave[h]
				IThalf_rate = half_ratewave[h]
				
				// run SimpleDendrite....first for the steep (ET) sigmoid
				DendriteParams [4] = ETslope
				DendriteParams [5] = EThalf_rate	
				SimpleDendriteSimulator($AveRateName,  DendriteParams) // output is the linear and the supralinear output in "voltage"
				wave linearVout, dendVout, rate_curve, linear	 // collect "voltage outputs" and the rate curves
				
						if (waveexists(linear)!=1)
							Abort "Wave \""+ nameofwave(linear) +"\" doesn't exist!"
						endif
				duplicate /o linear, Linear_rate_curve				
				linname = thistimewave[0, (strsearch(thistimewave, "_StS",0))]+"etaF_lin"
						
						if (waveexists(linearVout)!=1)
							Abort "Wave \""+ nameofwave(linearVout) +"\" doesn't exist!"
						endif
				
				duplicate /o linearVout, $linname
				print "writing ", linname, " as linear output"
				makeaVhistogram($linname)
				
				rate_curvename = "ET_"+half_rateTwave[h]+"_rate_curve"
				
				if (waveexists(rate_curve)!=1)
							Abort "Wave \""+ nameofwave(rate_curve) +"\" doesn't exist!"
						endif
				duplicate /o rate_curve, $rate_curvename
				ETname = thistimewave[0, (strsearch(thistimewave, "_StS",0))]+half_rateTwave[h]+"etaF_ETmV"
				
				if (waveexists(dendVout)!=1)
							Abort "Wave \""+ nameofwave(dendVout) +"\" doesn't exist!"
				endif
				duplicate /o dendVout, $ETname
				
				print "writing ", ETname, " as supralinear output"
				makeaVhistogram($ETname)
				// now do this for the shallow (IT) sigmoid
				DendriteParams [4] = ITslope
				DendriteParams [5] = IThalf_rate
				SimpleDendriteSimulator($AveRateName,  DendriteParams)
				
				rate_curvename = "IT_"+half_rateTwave[h]+"_rate_curve"
				
						if (waveexists(rate_curve)!=1)
							Abort "Wave \""+ nameofwave(rate_curve) +"\" doesn't exist!"
						endif
				
				duplicate /o rate_curve, $rate_curvename
				ITname = thistimewave[0, (strsearch(thistimewave, "_StS",0))]+half_rateTwave[h]+"etaF_ITmV"
				
				if (waveexists(dendVout)!=1)
							Abort "Wave \""+ nameofwave(dendVout) +"\" doesn't exist!"
				endif
				
				
				duplicate /o dendVout, $ITname				
				print "writing ", ITname, " as supralinear output"
				makeaVhistogram($ITname)
				// now do phase histogram
					phasehist (ETname, (1000/thecarrier))
					phasehist (ITname, (1000/thecarrier))
					phasehist (linname, (1000/thecarrier))

			endfor // end loop to go through different half frequencies
		
		endfor  // end the for loop going through all the waves as tracked by "i" for this carrier frequency

//...............................................................................................................................................................................//
		// collect the and average histograms of
		// the rate peaks, phase histograms, and the voltage histograms

		extractPeakHistograms(plusminusvalues, carrier_prefix, "*_etaRpks")
		extractPhaseHistograms(carrier_prefix, r)
		extractVoltageHistograms(carrier_prefix, r)
//...............................................................................................................................................................................//
//...............................................................................................................................................................................//

	endfor // end the for loop changing input condition as tracked by "run" from "carriername"  text wave
//...............................................................................................................................................................................//
	edit range_array
	ExtracttheSupraLinearRanges()	// hardwired to make expected output based on figure 8F, change if other values are tested

end
//------------------------------------------------------------------------------------------------------------------------------------------------//
//	end of StartHere()
//------------------------------------------------------------------------------------------------------------------------------------------------//




//------------------------------------------------------------------------------------------------------------------------------------------------//
function calcAveRatefromETAfilter(stimtimewave,len, ETAfilter)		// tranforms the stim times into a continuous function by convolving them with ETAfilter wave

wave stimtimewave 		// INPUT: series of stimulation times (impulses)	  ("*StS" wave) 
variable len				// INPUT: length of wave to convolve timepoints into
wave ETAfilter			// INPUT: kernel/filter wave from the ETA"

						// output is sfrate (the continous rate function), fscalewave (a copy of the kernel wave used for record keeping)
						 
print "calcAveRatefromETAfilter(", nameofwave(stimtimewave),",",len,",", nameofwave(ETAfilter),")"
print nameofwave(stimtimewave), "= wave with stimulus times"
print len, "=len (how many points to convolve)"
print nameofwave(ETAfilter), " = kernel/filter wave from the ETA"

make /o /n=(len) sfrate=0 // this wave is the output of this

variable i = 0

Variable tspike = 0
Variable lim=numpnts(stimtimewave)

	if (waveexists(stimtimewave)!=1)
					Abort "Wave \""+ nameofwave(stimtimewave) +"\" doesn't exist!"
	endif
	duplicate /o stimtimewave, stimIDwave

stimIDwave = 1

variable tID

//print lim, "=lim"

	do
	     tspike=(stimtimewave[i]/0.05)
	     tID = (stimIDwave[i])
	     
		if (tspike<(len-1))
		     sfrate[tspike]=tID
	       endif
	      i+=1
	while(i <lim)


if (waveexists(sfrate)!=1)
					Abort "Wave \""+ nameofwave(sfrate) +"\" doesn't exist!"
	endif
duplicate /o sfrate, thetrain
SetScale/P x 0,0.05,"", sfrate
SetScale/P x 0,0.05,"", thetrain


if (waveexists(ETAfilter)!=1)
					Abort "Wave \""+ nameofwave(ETAfilter) +"\" doesn't exist!"
	endif
duplicate /o ETAfilter, fscalewave

// do a check to make sure integral is 1
Integrate fscalewave/D=fscalewave_INT
wavestats /q fscalewave_INT
variable theintegral = round(V_max)
print theintegral, "= the integral of the kernel wave"
		if (theintegral != 1000)
			print "WOAH MAN INTEGRAL IS OFF!!!"
			print "Trust convolution rates at your own risk!"
		endif

convolve /a fscalewave, sfrate


End	
//------------------------------------------------------------------------------------------------------------------------------------------------//
//	// end of calcAveRatefromETAfilter()
// some notes on CONVOLUTION in IGORpro:	
// 	convolution IGNORES x-scaling (using only p scaling) in your "kernel" also called your "srcwave". In other words, your filter's scale doesn't matter!
//
//  "convolve /a" gives you "acausal linear convolution
//  "convolve /c" gives you circular convolution

// for each destination point, [m] dot product with filterwave [p-m]
// if it's circular, [p-m] is wrapped around on the source wave when you are > numpnts in source wave, for linear it's set to zero
// empirically: circular offsets the signal: -125  (1/2 the points in trace) 
//  For impulses to a continous function:
// Use acausal convolution when the source wave contains an impulse response where the MIDDLE POINT of srcWaveName  corresponds to no delay (t = 0).
//------------------------------------------------------------------------------------------------------------------------------------------------//






//------------------------------------------------------------------------------------------------------------------------------------------------//
function SimpleDendriteSimulator(InputRate, DendriteParams)		// a simple calculator of the voltage output given the continous input rate, for a dendrite with a sigmoid as specified by the wave DendriteParams

wave InputRate					// INPUT: continous input rate function, calculated alread from impulse times  ("*StS" wave) using calcAveRatefromETAfilter()
wave DendriteParams			// INPUT: the features of the dendrite: see details below:


								// outputs: linear voltage output ("linearVout"), supralinear voltage output ("dendVout"), linear voltage-rate curve ("linear")ê, supralinear (sigmoid+linear) voltage curve ("rate_curve")
print "SimpleDendriteSimulator(", nameofwave(InputRate), ", ", nameofwave(DendriteParams),")"
print "DendriteParams:"
print DendriteParams
// wave DendriteParams typically has {60, 0.002, 0, 12, 25, 760}
// 		number of inputs (spines)
//		linear component
// 		baselinevoltage (to normalize the sigmoid) typically 0 mV
//		maximumvoltage (to normalize the sigmoid) typically 12 mV
// 		Slope (25 for steep, 250 for shallow)
//		half_rate (760 Hz)
// 		
// 				wave linearVout, dendVout
// this function is hard wired to assume 10s is the time of your run


variable nos, lc, base, maxvolt,  slope, half_rate

nos = DendriteParams[0]
lc =  DendriteParams[1]
base =  DendriteParams[2]
maxvolt =  DendriteParams[3]
slope =  DendriteParams[4]
half_rate =  DendriteParams[5]

variable i
string freqname
variable length = numpnts(InputRate)*0.05
variable baseline = 0

print nos, "= number of inputs"
print lc , " linear component per Hz"
print lc*2000, "linear max"
print base, "base"
print maxvolt, "maximum supra"
print half_rate, "half_rate"
print slope, "slope"
print length, "=length"

make /o /n = 3100 linear
make /o /n = 2100 sigmoid

linear = x*lc
sigmoid = 1/(1+exp((half_rate-(x))/(slope)))

wavestats /q sigmoid
sigmoid-=V_min
wavestats /q sigmoid
sigmoid/=V_max
sigmoid*=(maxvolt*1)

if (waveexists(sigmoid)!=1)
					Abort "Wave \""+ nameofwave(sigmoid) +"\" doesn't exist!"
	endif
duplicate /o /r = (0, 2099) sigmoid, rate_curve
rate_curve+=linear

if (waveexists(InputRate)!=1)
					Abort "Wave \""+ nameofwave(InputRate) +"\" doesn't exist!"
	endif

duplicate /o InputRate, tempwave


if (waveexists(tempwave)!=1)
					Abort "Wave \""+ nameofwave(tempwave) +"\" doesn't exist!"
	endif
duplicate /o tempwave, dendVout
dendVout=0
wavestats /q tempwave
 		
			if (V_max>2000)			
				print "alert!!!"
				print V_max, "is above the range for a 2K Hz"
			endif


	 	dendVout = rate_curve(abs(tempwave(x)))

	if (waveexists(tempwave)!=1)
					Abort "Wave \""+ nameofwave(tempwave) +"\" doesn't exist!"
	endif
		
		duplicate /o tempwave, linearVout		
		linearVout = 0
		linearVout = linear(abs(tempwave(x)))
end
//------------------------------------------------------------------------------------------------------------------------------------------------//
//	end of SimpleDendriteSimulator
//------------------------------------------------------------------------------------------------------------------------------------------------//




//------------------------------------------------------------------------------------------------------------------------------------------------//
function FindMyRatePeaks(RateWave)		// this function finds the Peaks in the continuous rate function to capture the flavor of the inputs. Note this uses the "PeakAreas.ipf" procedures to collect the peaks (called MaxKnots) 

wave RateWave								// INPUT: continuous rate function for a particular trial/trace

											// output: MaxKnots: where the x-value is the time of the peak, d-value is the Hz of that peak. Gets copied over to "...etaRpks" in StartHere()
print "Finding the Peaks of the Rate with FindMyRatePeaks(", nameofwave(RateWave),")"
string executeme		// procedures are not meant to be called from functions, but this can be done using the "Execute" command with a string
string w = nameofwave (RateWave)	// w is the name of the wave we are finding peaks from


if( exists(w) != 1 )
		Abort "Wave \""+ w+"\" doesn't exist!"
	endif

// are the global parameters for peak finding already around?
if( exists("tfp_noise") == 0 )			
		executeme = "CreateTN020BGlobalVariables()"
		print executeme
		Execute executeme
	endif
	
// Code below:  replaces "InitializeMostEverything(w,wx,wb)" macro
string wb = "_None_"		// string of the baseline offset for peaks 
string wx = "_Calculated_"	// string indicated the x-wave

svar g_w, g_wx, g_b			// globals of wavename, x-scale wavename, baselinename
nvar g_bx							// global of box (approximate width of peak at 50%)
nvar mpr_pol						// global of peak polarity 1 = positive, 2 = negative
nvar mir_what						// global of the kind of output, should be 1 for "counts"
nvar  tfp_noise

g_w = w
g_wx = wx
g_b = wb
	
	executeme = "SBs(\""+wb+"\")"
	print executeme
	Execute	 executeme
	
	
	Redimension/D $w
	executeme = "SameLen(\""+w+"\",\"W_BaseRegion\")"	// SameLen duplicates the wave, or if it exists makes it have the same pnts and scaling
	Execute executeme
	wave W_BaseRegion
	W_BaseRegion=NaN
	executeme = "SameLen(\""+w+"\",\"W_AreaRegion\")"
	Execute executeme
	wave W_AreaRegion
	W_AreaRegion=NaN
	executeme = "Mk(\"W_EstAmpsY\",2)"
	Execute executeme
	executeme = "Mk(\"W_EstCentersX\",2)"
	Execute executeme
	executeme = "Mk(\"W_EstWidthsX\",2)"
	Execute executeme
	executeme = "Mk(\"W_EstCentersP\",2)"
	Execute executeme
	executeme = "Mk(\"W_EstEdgesP\",4)"
	Execute executeme
	executeme = "Mk(\"W_AreaNoBase\",2)"
	Execute executeme
	executeme = "Mk(\"W_AreaX1\",2)"
	Execute executeme
	executeme = "Mk(\"W_AreaX2\",2)"
	Execute executeme
	executeme = "Mk(\"W_BasePM\",2)"
	Execute executeme
	executeme = "Mk(\"W_PeakPM\",2)"
	Execute executeme

	if(exists(wx)==1)
		Redimension/D$wx
	endif
	
	if(exists(wb)==1)
		Redimension/D $wb
	endif

	executeme = "AppWv(\""+w+"\",\""+wx+"\",\"\")"	// pull the wave out of the folders (do we need this)
	fHideAreaTags()		// hide tags if they were there
	// end of the "InitializeMostEverything" Macro
	
	// need to hijack AutoIdentifyAndMeasurePeaks() because it asks for inputs
	
	//executeme ="InitIdentifyPeaks()"

	Variable box=10		// in ms the width of the peak at 50%
	Variable pol=1		// we are looking for positive peaks
	Variable what=1		// this means you are looking for counts out of this analysis
	
	mir_what = what
	mpr_pol = pol
	g_bx = box
	
	DoWindow/F PeakFitGraph
	if(V_Flag==0)
		executeme = "AppWv(\""+w+"\",\""+wx+"\",\"\")"
		Execute executeme
		DoWindow/C PeakFitGraph
	else
		executeme = "AppWv(\""+w+"\",\""+wx+"\",\"\")"
		Execute executeme
		fHideAreaTags()	
	endif
	
	executeme = "AppWv(\""+wb+"\",\""+wx+"\",\"\")"
	Execute executeme
	executeme = "AppCrs(\""+w+"\")"

	SetAxis/A left
	SetAxis/A bottom
	executeme = "ShowOnlyDataAndBase()"
	Execute executeme
	executeme = "AutoIdentifyPeaks(2,\""+g_w+"\",\""+g_wx+"\",\""+g_b+"\","+num2str(g_bx)+",1,"+num2str(tfp_noise)+")"
	print executeme
	Execute executeme

// 	the subsequent code is commented out, it's only for if you want to make a baseline from your peaks
	//	String kn
	//	if(pol==1) // positive peaks
	//		kn="W_MinKnots" // baseline from neg pks
	//	else
	//		kn="W_MaxKnots"
	//	endif
	//	executeme = "ConstructBaselineFromPeaks(\""+g_w+"\",\""+g_wx+"\",\""+kn+"\")"
	//	Execute executeme

// 	the subsequent code is commented out, it's only for if you want to make a table of the outputs with 
// 	the centers and edges of the peaks.
		//	string pfr_title = w+"_title"
		//	string  pfr_sort = w+"_sort"
		//	variable pfr_order = 2 // sort by peak
		//	executeme = "MeasureIdentifiedPeaks("+num2str(what)+",\""+pfr_title+"\",\""+pfr_sort+"\","+num2str(pfr_order)+","+num2str(pol)+")"
		//	Execute executeme


	wave W_MaxKnots
	if (waveexists(W_MaxKnots)!=1)
							Abort "Wave \""+ nameofwave(W_MaxKnots) +"\" doesn't exist!"
				endif
	duplicate /o W_MaxKnots, ThePeaksWave
end
//------------------------------------------------------------------------------------------------------------------------------------------------//
// end of FindMyRatePeaks()
//------------------------------------------------------------------------------------------------------------------------------------------------//





//------------------------------------------------------------------------------------------------------------------------------------------------//
function ProduceHistogramsofRatePeaks(inputwave) // for calculating the distribution of rates present in a particular continuous input rate function run split into 40 50 Hz bins from 10 Hz to 2010 Hz
wave inputwave										// INPUT: the continuous input rate for this trace's stimulations assumes,  this wave is 10 s long, x-scaled in ms (20 KHz)
													
													
print "ProduceHistogramsofRatePeaks(",nameofwave(inputwave),")"
string thewavesname = nameofwave(inputwave)+"_H" 		// name of ouptut (input name which should be ...pks + "_H")
print "making ",  thewavesname, "first bin at 10 Hz, 50 Hz wide bins, total of 40 bins (to 2000 Hz)"
Make/N=40/O $thewavesname
Histogram/B={10,50,40} inputwave,$thewavesname
end
//------------------------------------------------------------------------------------------------------------------------------------------------//
//	end of ProduceHistogramsofRatePeaks()
//------------------------------------------------------------------------------------------------------------------------------------------------//



//------------------------------------------------------------------------------------------------------------------------------------------------//
function makeaVhistogram(tracewave)			// for calculating the distribution of voltages present in a particular simulation run split into 0.5 mV bins from -3 mV to 18.5 mV
	wave tracewave								// INPUT: the trace/simulation wave you are making the histogram from, assumes this wave is 10 s long, x-scaled in ms (20 KHz)
print " makeaVhistogram(", nameofwave(tracewave),")"

	variable start = 10
	variable stop = 9990
	string tracehistname = nameofwave(tracewave)+"_H"			// name of output (input name which should be ...mV+"_H")
			if (waveexists(tracewave)!=1)
				Abort "Wave \""+ nameofwave(tracewave) +"\" doesn't exist!"
			endif
			duplicate /o tracewave, voltagewave
			
		wavestats /q voltagewave
		voltagewave-=V_min
		
		Make/N=40/O thetracehist
		Histogram/P/R=(start, stop)  /B={-3,0.5,40} voltagewave,thetracehist
		duplicate /o thetracehist, $tracehistname
end
//------------------------------------------------------------------------------------------------------------------------------------------------//
//	end of makeaVhistogram()
//------------------------------------------------------------------------------------------------------------------------------------------------//





//------------------------------------------------------------------------------------------------------------------------------------------------//
function phasehist(inputname,cycletime)	// for generating phase histogram
string inputname							// INPUT: dendrite simulation trace (voltage),  for10 s long, x-scaled in ms sampled at 20 KHz (deltax = 0.05)
variable cycletime 							// in ms how long a sinusiodal cycle is.

											// two outputs are made: one with the absoluted phase histogram ("_p") and one where it is normalized to the initial point ("_pN")

print "phasehist(", inputname,",", num2str(cycletime),")"

variable ptsofcycle =round(cycletime/0.05)
print ptsofcycle, " = points in a cycle"


if (waveexists($inputname)!=1)
	Abort "Wave \""+ inputname +"\" doesn't exist!"
endif
duplicate /o $inputname, wavetoprocess
wavestats /q wavetoprocess

variable theend = V_npnts
print V_npnts, " = the end"
variable numcycles = floor (V_npnts/ptsofcycle)
print "numcycles is ", numcycles
theend = numcycles*ptsofcycle

wavestats /q wavetoprocess
print theend-V_npnts, " = theend-V_npnts"


make /o /n=(ptsofcycle) cyclewave = 0
SetScale/P x 0,0.05, cyclewave
make /o /n=(ptsofcycle) sumwave
SetScale/P x 0,0.05, sumwave


variable i = 0
 


do 	
	if (waveexists($inputname)!=1)
					Abort "Wave \""+ inputname +"\" doesn't exist!"
	endif
	duplicate /o /r = [i, (i+ptsofcycle-1)] $inputname, cyclewave
	SetScale/P x 0,0.05, cyclewave
	sumwave+=cyclewave	
	i+= ptsofcycle
while (i < theend )

sumwave/=numcycles
SetScale/P x 0,0.05, sumwave
setscale /i x 0, 360, sumwave

string outname = inputname+"_p"

if (waveexists(sumwave)!=1)
	Abort "Wave \""+ nameofwave(sumwave) +"\" doesn't exist!"
endif

duplicate /o sumwave, $outname
appendtograph $outname


if (waveexists(sumwave)!=1)
	Abort "Wave \""+ nameofwave(sumwave) +"\" doesn't exist!"
endif
duplicate /o sumwave, normedwave
outname = inputname+"_pN"
variable normfactor = sumwave[0]
normedwave-=normfactor


if (waveexists(normedwave)!=1)
	Abort "Wave \""+ nameofwave(normedwave) +"\" doesn't exist!"
endif
duplicate /o normedwave, $outname

end
//------------------------------------------------------------------------------------------------------------------------------------------------//
//	end of phasehist()
//------------------------------------------------------------------------------------------------------------------------------------------------//



//------------------------------------------------------------------------------------------------------------------------------------------------//
function extractPeakHistograms(plusminuswave, prefix, suffix) // after running several simulations with the same input conditions, extract all the histograms collected  of the continuous input rate 
wave plusminuswave											// a wave indicating what the amplitude of the mean oscillating input
string prefix													// the name of the particular input condition 
string suffix													// what all the peak are called (typically: "_etaRpks")


																// this code then runs the compileandsortthepeaks code, running the proper set for the stimulus condition.
print "extractPeakHistograms(", nameofwave(plusminuswave),", ", prefix, ", ", suffix,")"
variable step, pm	// to track which plus or minus set we are collecting
string rpk_set_name
variable rp=0
string Freq_snippet		// extract the part of the suffix that is the carrier frequency 
string FreqInWavename	// the name for the wave showing the inhomogenous rate/frequency guiding the poisson processes			
			
			rpk_set_name = prefix+suffix // collect all the peaks wave based on the prefix, plus-minus value, suffix 
			print rpk_set_name," = rpk_set_name"
			
			FreqInWavename = prefix+"_Freq"
					if( waveexists($FreqInWavename) != 1 )
						Abort "Wave \""+ FreqInWavename+"\" doesn't exist!"
					endif
				compileandsortthepeaks(rpk_set_name, $FreqInWavename)	// 	
		
end

//------------------------------------------------------------------------------------------------------------------------------------------------//
//	end of ProduceHistogramsofRatePeaks()
//------------------------------------------------------------------------------------------------------------------------------------------------//

//
// Next series of analyses take advantage of Average waves code. Here are details on that. NOTE you need to have that .ipf package loaded
			//fWaveAverage(ListOfWaves, ListOfXWaves, ErrorType, ErrorInterval, AveName, ErrorName)
			//\	String ListOfWaves		// Y waves
			//	String ListOfXWaves		// X waves list. Pass "" if you don't have any.
			//	Variable ErrorType		// 0 = none; 1 = S.D.; 2 = Conf Int; 3 = Standard Error
			//	Variable ErrorInterval	// if ErrorType == 1, # of S.D.'s; ErrorType == 2, Conf. Interval
			//	String AveName, ErrorName



//------------------------------------------------------------------------------------------------------------------------------------------------//
function ExtractVoltageHistograms(carrier_prefix, array_row)		// after running several simulations with the same input conditions, extract all the Voltage Histograms from that input type and average them
string carrier_prefix												// INPUT: "the name of the input condition"
variable array_row													// INPUT: the "position" or "index" you are in the array/set of input conditions 
																	
																	// outputs:  
																	// "...halfrate...ETVHistAve, ETVSE (average and standard error of voltage histograms) for each of the steep half maximum rate curves
																	// "....halfrate..ITVHistAve, ITVSE (average and standard error of voltage histograms) for each of the shallow half maximum rate curves
																	// "...linVHistAve, linVSE (average and standard error of voltage histograms) for each the linear curve (note! no half-rates here)

wave /t half_rateTwave
wave inputprops

string whichrate, Setsname, Sets2Average, meanoutname, seoutname
variable numinset
variable w=0
wave range_array
wave inputprops
variable range
variable numtypes2process

	if (array_row==2 || array_row ==5) 	

		for (w=0; w<numpnts(half_rateTwave); w+=1)
			whichrate = half_rateTwave[w]

			// first do this for the ET-type
			Setsname = carrier_prefix+"*"+whichrate+"*ETmV_H"
			meanoutname = carrier_prefix[0, 5]+"_"+whichrate+"_ETVHistAve"
			seoutname = carrier_prefix[0, 5]+"_"+whichrate+"_ETVHistSE"
			Sets2Average = sortlist(wavelist (Setsname, ";", ""))
			numinset = itemsinlist(Sets2Average, ";")
			print numinset, "= number of waves to average"
			if (numinset>1)
				fWaveAverage(Sets2Average, "", 3, 1, meanoutname, seoutname) // collect average			
			else
				if (waveexists($stringfromlist(0, Sets2Average))!=1)
						Abort "Wave \""+ stringfromlist(0, Sets2Average) +"\" doesn't exist!"
				endif
				duplicate /o $stringfromlist(0, Sets2Average), $meanoutname	
				duplicate/o $meanoutname, theerror
				theerror = 0 
				duplicate/o theerror, $seoutname		
			endif
			// now do this for the IT-type
			Setsname = carrier_prefix+"*"+whichrate+"*ITmV_H"
			meanoutname = carrier_prefix[0, 5]+"_"+whichrate+"_ITVHistAve"
			seoutname = carrier_prefix[0, 5]+"_"+whichrate+"_ITVHistSE"
			Sets2Average = sortlist(wavelist (Setsname, ";", ""))

			numinset = itemsinlist(Sets2Average, ";")
			if (numinset>1)
				fWaveAverage(Sets2Average, "", 3, 1, meanoutname, seoutname) // collect average
			else
				if (waveexists($stringfromlist(0, Sets2Average))!=1)
					Abort "Wave \""+ stringfromlist(0, Sets2Average) +"\" doesn't exist!"
				endif
				duplicate /o $stringfromlist(0, Sets2Average), $meanoutname	
				duplicate/o $meanoutname, theerror
				theerror = 0 
				duplicate/o theerror, $seoutname
			endif
		endfor	

		// now do this for the linear type		// only do one, there is no half-width dependence
			Setsname = carrier_prefix+"*"+"lin_H"
			meanoutname = carrier_prefix[0, 5]+"_linVHistAve"
			seoutname = carrier_prefix[0, 5]+"_linVHistSE"
			Sets2Average = sortlist(wavelist (Setsname, ";", ""))

			numinset = itemsinlist(Sets2Average, ";")
			if (numinset>1)
				fWaveAverage(Sets2Average, "", 3, 1, meanoutname, seoutname) // collect average
			else
			
				if (waveexists($stringfromlist(0, Sets2Average))!=1)
					Abort "Wave \""+ stringfromlist(0, Sets2Average) +"\" doesn't exist!"
				endif
				duplicate /o $stringfromlist(0, Sets2Average), $meanoutname	
				duplicate/o $meanoutname, theerror
				theerror = 0 
				duplicate/o theerror, $seoutname
			endif
			
	endif

end
//------------------------------------------------------------------------------------------------------------------------------------------------//
//	end of ExtractVoltageHistograms(carrier_prefix, array_row)
//------------------------------------------------------------------------------------------------------------------------------------------------//




																	



//------------------------------------------------------------------------------------------------------------------------------------------------//
function extractPhaseHistograms(carrier_prefix, array_row)	// after running several simulations with the same input conditions, extract all the Phase Histograms from that input type and average them
string carrier_prefix												// INPUT: "the name of the input condition"		this code collects the absolute phase histograms ("_p"), not the normalized ones 
variable array_row													// INPUT: the "position" or "index" you are in the array/set of input conditions 

																	// outputs:  
																	// "...halfrate...ETPhHistAve, ETPhSE (average and standard error of phase histograms) for each of the steep half maximum rate curves
																	// "....halfrate..ITphHistAve, ITPhSE (average and standard error of phase histograms) for each of the shallow half maximum rate curves
																	// "...linPhHistAve, linPhSE (average and standard error of phase histograms) for each the linear curve (note! no half-rates here)

																	// Average the phase voltage histograms and from these calculate the peak-to-trough oscillation size
																	// this will be stored in a multi-d wave (range_array)

wave /t half_rateTwave
string whichrate, Setsname, Sets2Average, meanoutname, seoutname
variable numinset
variable w=0
wave range_array
wave inputprops
variable range
	
		for (w=0; w<numpnts(half_rateTwave); w+=1)
			whichrate = half_rateTwave[w]
			// first do this for the ET-type
			Setsname = carrier_prefix+"*"+whichrate+"*ETmV_p"
			meanoutname = carrier_prefix[0, 5]+"_"+whichrate+"_ETPhAve"
			seoutname = carrier_prefix[0, 5]+"_"+whichrate+"_ETPhSE"
			Sets2Average = sortlist(wavelist (Setsname, ";", ""))
			numinset = itemsinlist(Sets2Average, ";")
			print numinset, "= number of waves to average"
			if (numinset>1)
				fWaveAverage(Sets2Average, "", 3, 1, meanoutname, seoutname) // collect average
			
			else
			
				if (waveexists($stringfromlist(0, Sets2Average))!=1)
						Abort "Wave \""+ stringfromlist(0, Sets2Average) +"\" doesn't exist!"
				endif
							duplicate /o $stringfromlist(0, Sets2Average), $meanoutname	
				duplicate/o $meanoutname, theerror
				theerror = 0 
				duplicate/o theerror, $seoutname
			endif

			wavestats /q $meanoutname
			range = V_max-V_min
			range_array[array_row][0][w] = range

			Setsname = carrier_prefix+"*"+whichrate+"*ITmV_p"
			meanoutname = carrier_prefix[0, 5]+"_"+whichrate+"_ITPhAve"
			seoutname = carrier_prefix[0, 5]+"_"+whichrate+"_ITPhSE"
			Sets2Average = sortlist(wavelist (Setsname, ";", ""))


			numinset = itemsinlist(Sets2Average, ";")
			if (numinset>1)
				fWaveAverage(Sets2Average, "", 3, 1, meanoutname, seoutname) // collect average
			else
				if (waveexists($stringfromlist(0, Sets2Average))!=1)
					Abort "Wave \""+ stringfromlist(0, Sets2Average) +"\" doesn't exist!"
				endif
								duplicate /o $stringfromlist(0, Sets2Average), $meanoutname	
				duplicate/o $meanoutname, theerror
				theerror = 0 
				duplicate/o theerror, $seoutname
			endif
			
			wavestats /q $meanoutname
			range = V_max-V_min
			range_array[array_row][1][w] = range
			
			
			Setsname = carrier_prefix+"*"+"lin_p"
			meanoutname = carrier_prefix[0, 5]+"_linPhAve"
			seoutname = carrier_prefix[0, 5]+"_linPhSE"
			Sets2Average = sortlist(wavelist (Setsname, ";", ""))

			numinset = itemsinlist(Sets2Average, ";")
			if (numinset>1)
				fWaveAverage(Sets2Average, "", 3, 1, meanoutname, seoutname) // collect average
			else
			
				if (waveexists($stringfromlist(0, Sets2Average))!=1)
					Abort "Wave \""+ stringfromlist(0, Sets2Average) +"\" doesn't exist!"
				endif
								duplicate /o $stringfromlist(0, Sets2Average), $meanoutname	
				duplicate/o $meanoutname, theerror
				theerror = 0 
				duplicate/o theerror, $seoutname
			endif
			
			wavestats /q $meanoutname
			range = V_max-V_min
			range_array[array_row][2][w] = range
		endfor // end of the for loop collecting and analyzing the averaged phase histograms and making the range_array wave
		
end
//------------------------------------------------------------------------------------------------------------------------------------------------//
//	end of extractPhaseHistograms(carrier_prefix, array_row)
//------------------------------------------------------------------------------------------------------------------------------------------------//



//------------------------------------------------------------------------------------------------------------------------------------------------//
function compileandsortthepeaks(PeaksName, FreqWave)		// this function is for separating peaks in the input rate when mean input rate is oscillating:
																// split peaks into two groups: when the collective input rate is "above" and "below" the mean input rate
																// also collects all peaks in an "all" wave
																// then generates histograms shown in for Figure 8A&E by calling ProduceHistogramsofRatePeaks()


string PeaksName  				// INPUT: Name of the wave with the peaks of the Rate function (as calculated by TN020C/PeakAreas, often called "W_MaxKnots")
wave FreqWave 					// INPUT: wave of the oscillating mean rate of the input (typically "...Freq")

print "sortthepeaks(", PeaksName, ",", nameofwave(Freqwave),")"

string thewavestoprocess
thewavestoprocess = sortlist(wavelist (PeaksName, ";", "") )
variable howmanywaves = itemsinlist (thewavestoprocess, ";")
print "Processing this many waves: ", num2str(howmanywaves)
print thewavestoprocess

variable step = 0
variable i
variable thispoint
variable a = 0
variable b = 0
variable c = 0
variable peak, peaktime
variable thismany
variable oscflag	// is the input rate/freq changing?
wavestats /q Freqwave
variable mid = V_avg
variable dev = V_sdev
if (dev!=0)
	Print "The rate oscillates around: ", num2str(mid), " Hz"
	oscflag=1
else
	Print "The rate is fixed at: ", num2str(mid), " Hz"
	oscflag=0
endif

// destination waves for the peaks:
make /o /n = 1 abovewave		
make /o /n = 1 belowwave
make /o /n = 1 allwave

string thiswave

for (step=0; step<howmanywaves; step+=1)		
	// collect a rate wave wave
	thiswave = stringfromlist (step, thewavestoprocess)
				if (waveexists($thiswave)!=1)
					Abort "Wave \""+ thiswave +"\" doesn't exist!"
				endif
	duplicate /o $thiswave, workingwave
	wavestats /q workingwave
			
				if (waveexists(workingwave)!=1)
					Abort "Wave \""+ nameofwave(workingwave) +"\" doesn't exist!"
				endif
	
	duplicate /o workingwave, thexpoints
	thexpoints =x		// collect that waves xpoints
	thismany = V_npnts
	thexpoints = (numtype(workingwave)==2) ? NaN : thexpoints		//if the rate wave is NaN, make the xpoint NaN
	// eliminate all NaNs
	wavetransform zapNans, workingwave		
	wavetransform zapNans, thexpoints


		for (i = 0; i<thismany; i+=1)
			peaktime = thexpoints[i]				// cycle through all the peaks and find when they occurred
			thispoint = peaktime/0.05			// assuming you are sampling at 20KHz, get the "point" at that time

				// sort the peak into above or below waves:
				if (FreqWave[thispoint] > mid)	
					abovewave[a] = workingwave[i]
					a+=1
					InsertPoints a,1, abovewave
				else
					belowwave[b] = workingwave[i]
					b+=1
					InsertPoints b,1, belowwave
				endif
				
					allwave[c] = workingwave[i]	
					c+=1		
					InsertPoints c, 1, allwave	
					
				
		endfor		// endloop for cycling through peaks of a particular wave

		i=0
	
	endfor	// endloop for processing different waves in the list

string abovename, belowname, allname, basename

basename = PeaksName[0, (strsearch(PeaksName, "*", 0)-1)]
abovename = basename+"_etaRpks_abv"
belowname = basename+"_etaRpks_bel"
allname = basename+"_etaRpks_all"


				if (waveexists(abovewave)!=1)
					Abort "Wave \""+ nameofwave(abovewave) +"\" doesn't exist!"
				endif
				if (waveexists(belowwave)!=1)
					Abort "Wave \""+ nameofwave(belowwave) +"\" doesn't exist!"
				endif
				if (waveexists(allwave)!=1)
					Abort "Wave \""+ nameofwave(allwave) +"\" doesn't exist!"
				endif
duplicate /o abovewave, $abovename
duplicate /o belowwave, $belowname
duplicate /o allwave, $allname

	if (oscflag==1)
	ProduceHistogramsofRatePeaks($abovename)
	ProduceHistogramsofRatePeaks($belowname)
	endif
	ProduceHistogramsofRatePeaks($allname)
end
//------------------------------------------------------------------------------------------------------------------------------------------------//
//	end of compileandsortthepeaks()
//------------------------------------------------------------------------------------------------------------------------------------------------//







//------------------------------------------------------------------------------------------------------------------------------------------------//
function ExtracttheSupraLinearRanges()		// this extracts data for Figure 8D and 8F		
												//where carriernames = {"p2c001", "p2c003", "p0c007", "p1c007", "p2c007", "p4c007","p2c010", "p2c030", "p2c050", "p2c100"}
wave range_array 								// INPUT: a 3-d array generated by "StartHere()" and filled by the extractPhaseHistograms()

make /o /t /n = 8 Outnamelist 
Outnamelist = {"ETpmZero", "ITpmZero", "ETpmOneHz", "ITpmOneHz", "ETpmTwoHz", "ITpmTwoHz", "ETpmFourHz", "ITpmFourHz"}


make /o /t /n = 3 CarrierOutList
CarrierOutList = {"Oscamp_ET_cFreqs", "Oscamp_ET_cFreqs", "Oscamp_lin_cFreqs"}
make /o /n = 7 processcarriers
processcarriers = {0, 1, 4, 6, 7, 8, 9}
make /o /n = 7 CarrierRateX
CarrierRateX = {1, 3, 7, 10, 30, 50, 100}
make /o /n = 7 ETcValues
make /o /n = 7 ITcValues
make /o /n = 7 lincValues
make /o /n = 4 ETvalues
make /o /n = 4 ITvalues
make /o /n=4 IR_relative
IR_relative = {-400, -200, 0, 200}



variable pm, hr, c, a // to track plus-minus and half-rates in for loops and carrier frequency loop.
variable counter =0 // to track which output wave we are generating
string outname = OutnameList[counter]


	for (pm = 2; pm < 6; pm+=1) 		// extracting different plus or minus values	
			a = 0
			for (hr = 4; hr > 0 ; hr-=1)
				ETvalues [a] = range_array[pm][0][hr-1] - range_array [pm][2][hr-1]
				ITvalues [a] =  range_array[pm][1][hr-1] - range_array [pm][2][hr-1]
				a+=1
			endfor
			
			outname = OutnameList[counter]
			if (waveexists(ETvalues)!=1)
					Abort "Wave \""+ nameofwave(ETvalues) +"\" doesn't exist!"
				endif
			duplicate /o ETvalues, $outname
				
				if (counter<1)
					edit $outname
				else
					appendtotable $outname
				endif		
				
				counter+=1
				
				outname = OutnameList[counter]
							if (waveexists(ITvalues)!=1)
					Abort "Wave \""+ nameofwave(ITvalues) +"\" doesn't exist!"
				endif
				
				duplicate /o ITvalues $outname
				appendtotable $outname
				counter+=1			
	endfor
	// now extract the carriers: all at plus-minus 2 Hz
	for (c = 0; c<7; c+=1)
		ETcValues [c] = range_array[(processcarriers[c])][0][1]
		ITcValues [c]= range_array[(processcarriers[c])][1][1]
		lincValues[c] = range_array[(processcarriers[c])][2][1]
	endfor
		edit CarrierRateX, ETcValues, ITcValues, lincValues
	

end
//------------------------------------------------------------------------------------------------------------------------------------------------//
//	end of ExtracttheSupraLinearRanges()
//------------------------------------------------------------------------------------------------------------------------------------------------//